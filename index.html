<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System by El-Amir</title>

    <style>
        body {
            margin : 0;
            overflow: hidden;
        }
    </style>
   
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <script>
        
        // defining our global variables 
        var scene, camera, renderer, orbit;
        var textureLoader; 

        // sun and planets from the closest to the sun 
        var sun, mercury, venus, earth, mars, jupiter, saturn, uranus, neptune;
        
        var moon;
        var earthSystem; 
        var systems = []; // We will use this array to animate all planet systems

        init();
        animate();


        // instead of making a number of xplanets , making a function which is our init , 
        // takes size and texture of the planet
        // x and z why nto y ? because y will be our (المسله)
        // obribit speed based on the speed of each one 

        function createPlanet(size, texturePath, positionX, positionZ, orbitSpeed) {
            const geometry = new THREE.SphereGeometry(size, 30, 30);
            const material = new THREE.MeshStandardMaterial({
                map: textureLoader.load(texturePath)
            });
            
            const planet = new THREE.Mesh(geometry, material);
            
            // This is an invisible group. We position the group,
            // and add the planet to it (at 0,0,0 inside the group).
            const system = new THREE.Object3D();
            system.position.x = positionX; //group initial position
            scene.add(system); 
            system.add(planet);
            
            // we will choose later the positions 
            system.userData = {
                orbitX: positionX,
                orbitZ: positionZ,
                speed: orbitSpeed,
                planetInstance: planet // since we need a moon or moons for planets we will add it to the system data 
            };
            
            // adding it the array (dictionary )
            systems.push(system); // Add the system to our animation array
            
            createOrbitPath(positionX, positionZ);
            
            return planet;
        }


        // in the course we have made the path using the ring thing , but we will use it later with saturn's ring :D 

        function createOrbitPath(orbitX, orbitZ) {
            const curve = new THREE.EllipseCurve(
                0, 0,
                orbitX, orbitZ,
                0, 2 * Math.PI,
                false,
                0
            );

            // the more the mpoints the more it will be seen 
            const points = curve.getPoints(100);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x333333 });
            
            // we will make the ellipse and give it a color and geo and material 
            const ellipse = new THREE.Line(geometry, material);
            
            // rotation on x because all of the planets are on it , based on the rotation of the planets actually 
            // doesnt matter if it's positive or negative 
            ellipse.rotation.x = -Math.PI / 2;
            scene.add(ellipse);
        }

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                45, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                4000
            );
            camera.position.set(0, 350, 700); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // the light comes out from default which will be the sun 
            const pointLight = new THREE.PointLight(0xffffff, 2, 3000);
            scene.add(pointLight); 

            // this light somehow looks better 
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);

            textureLoader = new THREE.TextureLoader();

            const starTexture = textureLoader.load('Sun-moon-stars/2k_stars_milky_way.jpg');
            scene.background = starTexture;

            // we will implenet the sun using meshbasicmaterial so it doesnt get affected by the light its the sun afterall lol
            const sunGeometry = new THREE.SphereGeometry(35, 30, 30);
            const sunMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load('Sun-moon-stars/2k_sun.jpg')
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);
            
            // let any ai make those numbers because it's just asimulation 
            mercury = createPlanet(3.2, 'Planets2k/2k_mercury.jpg', 60, 50, 4);
            venus = createPlanet(5.8, 'Planets2k/2k_venus_surface.jpg', 110, 90, 1.5);
            
            //Earth with the moons (systems)
            earthSystem = new THREE.Object3D(); 
            const earthData = { orbitX: 160, orbitZ: 140, speed: 1 };
            earthSystem.userData = earthData;
            earthSystem.position.x = earthData.orbitX;
            scene.add(earthSystem);
            systems.push(earthSystem); // Add the whole system to the animation array
            createOrbitPath(earthData.orbitX, earthData.orbitZ);
            
            const earthGeometry = new THREE.SphereGeometry(6, 30, 30);
            const earthMaterial = new THREE.MeshStandardMaterial({
                map: textureLoader.load('Earth/2k_earth_daymap.jpg')
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earthSystem.add(earth); // Add Earth to the system group
            earthSystem.userData.planetInstance = earth; // Store for rotation


                // LIKE WE did with all of the planets making the sun their center , the moon center will be the earth here 
            const moonGeometry = new THREE.SphereGeometry(1.6, 30, 30);
            const moonMaterial = new THREE.MeshStandardMaterial({
                map: textureLoader.load('Sun-moon-stars/2k_moon.jpg')
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.x = 10; // away from the earth by 10 
            earthSystem.add(moon); // adding moon the the earth system 
            



            // other planets 
            mars = createPlanet(4, 'Planets2k/2k_mars.jpg', 210, 190, 0.8);
            jupiter = createPlanet(18, 'Planets2k/2k_jupiter.jpg', 300, 260, 0.4);
            saturn = createPlanet(16, 'Planets2k/2k_saturn.jpg', 450, 400, 0.2);
            
            // Saturns ring 
            const ringGeometry = new THREE.RingGeometry(20, 32, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load('Planets2k/2k_saturn_ring_alpha.png'),
                side: THREE.DoubleSide,
                transparent: true
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            saturn.add(ring); // adding the ring as child for saturn 
            
            uranus = createPlanet(10, 'Planets2k/2k_uranus.jpg', 580, 510, 0.1);
            neptune = createPlanet(10, 'Planets2k/2k_neptune.jpg', 700, 630, 0.05);

            orbit = new THREE.OrbitControls(camera, renderer.domElement);
            orbit.enableDamping = true;
            orbit.dampingFactor = 0.05;

            window.addEventListener('resize', onWindowResize);
        }

        function animate() {
            requestAnimationFrame(animate);

            // this gives actually a real time simulation 
            const time = Date.now() * 0.0001;

            sun.rotation.y += 0.002;

            systems.forEach(system => {
                // let each planet spin on its on axis
                // we will feel it's the not the same speed but its acutally the same speed for all but different distances
                if (system.userData.planetInstance) {
                    system.userData.planetInstance.rotation.y += 0.01;
                }
                
                // circlar
                // This moves the whole system (the invisible group)
                system.position.x = system.userData.orbitX * Math.cos(time * system.userData.speed);
                system.position.z = system.userData.orbitZ * Math.sin(time * system.userData.speed);
            });

            // this is like an embedded system like the sun but for the earth which will let the moon 
            earthSystem.rotation.y += 0.01;

            orbit.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
    
</body>
</html>